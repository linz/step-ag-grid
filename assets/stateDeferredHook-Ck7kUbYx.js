import{r as o}from"./iframe-fuNulc0f.js";const a=e=>{const t=o.useRef();return o.useEffect(()=>{t.current=e},[e]),t.current},i=(e,t)=>{const r=a(t);o.useEffect(()=>{if(r){let s=!0;Object.keys(t).forEach(c=>{t[c]!==r[c]&&(s&&(console.log("--- props changed -----"),s=!1),console.log(`${e} key: ${c} changed`))})}},[r,t,e])};try{a.displayName="usePrevious",a.__docgenInfo={description:"Track previous values of states.",displayName:"usePrevious",props:{}}}catch{}try{i.displayName="usePropMonitor",i.__docgenInfo={description:"Dump prop differences for components between renders.",displayName:"usePropMonitor",props:{}}}catch{}const u=()=>{const e=o.useRef(),t=()=>{if(e.current){const s=e.current;e.current=void 0,clearTimeout(s)}},r=o.useCallback((s,c)=>{t(),e.current=setTimeout(s,c)},[]);return o.useEffect(()=>()=>t(),[]),r};try{u.displayName="useTimeoutHook",u.__docgenInfo={description:`Cancels timeouts on scope being destroyed.

This could almost be a debounce, but debounce tracks by function reference, this tracks by hook reference.
This could have been implemented using debounce if the callers function was wrapped in useCallback,
but there's no way to enforce that, so  it would lead to bugs.`,displayName:"useTimeoutHook",props:{}}}catch{}const d=e=>{const t=o.useRef(0),r=u(),[s,c]=o.useState(e),l=o.useCallback(n=>{t.current=Date.now(),c(n)},[]),p=o.useCallback((n,f)=>{const _=Math.max(f-(Date.now()-t.current),0);r(()=>c(n),_)},[r]);return[s,l,p]};try{d.displayName="useStateDeferred",d.__docgenInfo={description:"Defers state change up to a minimum time since last state change.",displayName:"useStateDeferred",props:{}}}catch{}export{d as a,a as u};
